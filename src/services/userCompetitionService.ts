/**
 * USER COMPETITION SERVICE
 *
 * Handles user participation in the Arena competition:
 * - User portfolio management
 * - Signal taking (users join signals generated by Intelligence Hub)
 * - XP and achievement system
 * - Leaderboard rankings
 * - Anti-gaming measures
 */

import { supabase } from '@/integrations/supabase/client';
import { mockTradingService, type MockTradingPosition } from './mockTradingService';
import type { HubSignal } from './globalHubService';

// ===== TYPES =====

export interface UserProfile {
  id: string;
  email: string;
  username: string;
  created_at: string;

  // Competition stats
  balance: number;
  initial_balance: number;
  total_pnl: number;
  total_pnl_percent: number;
  total_trades: number;
  wins: number;
  losses: number;
  win_rate: number;

  // Gamification
  xp: number;
  level: number;
  achievements: string[];
  win_streak: number;
  max_win_streak: number;

  // Metadata
  last_trade_at: string | null;
  is_banned: boolean;
}

export interface UserAchievement {
  id: string;
  name: string;
  description: string;
  icon: string;
  xp_reward: number;
  unlocked_at: string | null;
}

export interface LeaderboardEntry {
  rank: number;
  user_id: string;
  username: string;
  is_agent: boolean;
  agent_name?: string;
  total_pnl_percent: number;
  total_trades: number;
  win_rate: number;
  level: number;
  xp: number;
}

export interface CompetitionPeriod {
  id: string;
  name: string; // "Weekly Challenge #1", "January 2025"
  type: 'weekly' | 'monthly';
  start_date: string;
  end_date: string;
  prize_amount: number;
  prize_currency: 'USD';
  sponsor?: string;
  winner_user_id?: string;
  status: 'upcoming' | 'active' | 'completed';
}

// ===== CONSTANTS =====

const INITIAL_BALANCE = 10000; // $10,000 starting capital
const XP_PER_TRADE = 10;
const XP_FOR_WIN = 25;
const XP_FOR_LOSS = 5;
const LEVEL_XP_MULTIPLIER = 100; // Level 1 = 100 XP, Level 2 = 200 XP, etc.

const ACHIEVEMENTS: UserAchievement[] = [
  {
    id: 'first_trade',
    name: 'First Steps',
    description: 'Place your first trade',
    icon: 'üéØ',
    xp_reward: 50,
    unlocked_at: null
  },
  {
    id: 'ten_trades',
    name: 'Getting Started',
    description: 'Complete 10 trades',
    icon: 'üöÄ',
    xp_reward: 100,
    unlocked_at: null
  },
  {
    id: 'first_win',
    name: 'Profitable',
    description: 'Win your first trade',
    icon: 'üí∞',
    xp_reward: 75,
    unlocked_at: null
  },
  {
    id: 'win_streak_3',
    name: 'Hot Streak',
    description: 'Win 3 trades in a row',
    icon: 'üî•',
    xp_reward: 150,
    unlocked_at: null
  },
  {
    id: 'beat_agent',
    name: 'Machine Slayer',
    description: 'Achieve higher ROI than an AI agent',
    icon: '‚öîÔ∏è',
    xp_reward: 300,
    unlocked_at: null
  }
];

// ===== SERVICE CLASS =====

class UserCompetitionService {
  private initialized = false;

  /**
   * Initialize user competition service
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    console.log('[UserCompetition] üéÆ Initializing user competition service...');

    // Ensure mock_trading_accounts and user_profiles tables exist
    // (handled by Supabase migrations)

    this.initialized = true;
    console.log('[UserCompetition] ‚úÖ Initialized successfully');
  }

  /**
   * Create or get user profile
   */
  async getOrCreateUserProfile(userId: string, email: string): Promise<UserProfile> {
    try {
      // Check if profile exists
      const { data: existing, error: fetchError } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('id', userId)
        .single();

      if (existing && !fetchError) {
        return this.formatUserProfile(existing);
      }

      // Create new profile
      const username = email.split('@')[0]; // Default username from email

      const { data: profile, error: createError } = await supabase
        .from('user_profiles')
        .insert({
          id: userId,
          email,
          username,
          balance: INITIAL_BALANCE,
          initial_balance: INITIAL_BALANCE,
          xp: 0,
          level: 1,
          achievements: [],
          win_streak: 0,
          max_win_streak: 0
        })
        .select()
        .single();

      if (createError) throw createError;

      // Create mock trading account for user
      await mockTradingService.getOrCreateAccount(userId);

      console.log(`[UserCompetition] ‚úÖ Created profile for user ${userId}`);
      return this.formatUserProfile(profile);

    } catch (error) {
      console.error('[UserCompetition] Error creating user profile:', error);
      throw error;
    }
  }

  /**
   * Take a signal (user joins a signal from Intelligence Hub)
   */
  async takeSignal(userId: string, signal: HubSignal, positionSize?: number): Promise<MockTradingPosition> {
    try {
      console.log(`[UserCompetition] üìä User ${userId} taking signal ${signal.id}`);

      // Get user profile
      const profile = await this.getUserProfile(userId);
      if (!profile) {
        throw new Error('User profile not found');
      }

      // Check rate limits (max 10 trades per day for free users)
      const todayTrades = await this.getTodayTradeCount(userId);
      if (todayTrades >= 10) {
        throw new Error('Daily trade limit reached (10 trades/day). Upgrade to Pro for unlimited trades.');
      }

      // Calculate position size (default 1% of balance)
      const size = positionSize || profile.balance * 0.01;

      // Place trade via mock trading service
      const position = await mockTradingService.placeOrder(userId, {
        symbol: signal.symbol,
        side: signal.direction === 'LONG' ? 'BUY' : 'SELL',
        quantity: size / signal.entry!,
        price: signal.entry!,
        leverage: 1
      });

      // Award XP for trade
      await this.awardXP(userId, XP_PER_TRADE, 'trade_placed');

      // Check for first trade achievement
      if (profile.total_trades === 0) {
        await this.unlockAchievement(userId, 'first_trade');
      }

      // Check for 10 trades achievement
      if (profile.total_trades + 1 === 10) {
        await this.unlockAchievement(userId, 'ten_trades');
      }

      console.log(`[UserCompetition] ‚úÖ User ${userId} opened ${position.side} on ${position.symbol}`);
      return position;

    } catch (error) {
      console.error('[UserCompetition] Error taking signal:', error);
      throw error;
    }
  }

  /**
   * Close a position and update stats
   */
  async closePosition(userId: string, positionId: string): Promise<void> {
    try {
      // Close via mock trading service
      await mockTradingService.closePosition(userId, positionId);

      // Get closed position to check if win/loss
      const { data: position } = await supabase
        .from('mock_trading_positions')
        .select('*')
        .eq('id', positionId)
        .single();

      if (!position) return;

      const isWin = position.profit_loss > 0;

      // Award XP
      const xpReward = isWin ? XP_FOR_WIN : XP_FOR_LOSS;
      await this.awardXP(userId, xpReward, isWin ? 'win' : 'loss');

      // Update win streak
      if (isWin) {
        await this.updateWinStreak(userId, true);

        // Check for first win achievement
        const profile = await this.getUserProfile(userId);
        if (profile && profile.wins === 1) {
          await this.unlockAchievement(userId, 'first_win');
        }
      } else {
        await this.updateWinStreak(userId, false);
      }

      console.log(`[UserCompetition] Position ${positionId} closed: ${isWin ? 'WIN' : 'LOSS'}`);

    } catch (error) {
      console.error('[UserCompetition] Error closing position:', error);
      throw error;
    }
  }

  /**
   * Award XP to user
   */
  private async awardXP(userId: string, amount: number, reason: string): Promise<void> {
    try {
      const profile = await this.getUserProfile(userId);
      if (!profile) return;

      const newXP = profile.xp + amount;
      const newLevel = this.calculateLevel(newXP);

      await supabase
        .from('user_profiles')
        .update({
          xp: newXP,
          level: newLevel
        })
        .eq('id', userId);

      if (newLevel > profile.level) {
        console.log(`[UserCompetition] üéâ User ${userId} leveled up to ${newLevel}!`);
      }

    } catch (error) {
      console.error('[UserCompetition] Error awarding XP:', error);
    }
  }

  /**
   * Calculate level from XP
   */
  private calculateLevel(xp: number): number {
    // Level 1 = 0-99 XP
    // Level 2 = 100-299 XP
    // Level 3 = 300-599 XP
    // Level n = (n-1) * 100 XP
    return Math.floor(Math.sqrt(xp / LEVEL_XP_MULTIPLIER)) + 1;
  }

  /**
   * Update win streak
   */
  private async updateWinStreak(userId: string, isWin: boolean): Promise<void> {
    try {
      const profile = await this.getUserProfile(userId);
      if (!profile) return;

      const newStreak = isWin ? profile.win_streak + 1 : 0;
      const newMaxStreak = Math.max(profile.max_win_streak, newStreak);

      await supabase
        .from('user_profiles')
        .update({
          win_streak: newStreak,
          max_win_streak: newMaxStreak
        })
        .eq('id', userId);

      // Check for win streak achievements
      if (newStreak === 3) {
        await this.unlockAchievement(userId, 'win_streak_3');
      }

    } catch (error) {
      console.error('[UserCompetition] Error updating win streak:', error);
    }
  }

  /**
   * Unlock achievement for user
   */
  async unlockAchievement(userId: string, achievementId: string): Promise<void> {
    try {
      const profile = await this.getUserProfile(userId);
      if (!profile) return;

      // Check if already unlocked
      if (profile.achievements.includes(achievementId)) return;

      const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
      if (!achievement) return;

      // Add to achievements array
      const updatedAchievements = [...profile.achievements, achievementId];

      await supabase
        .from('user_profiles')
        .update({
          achievements: updatedAchievements
        })
        .eq('id', userId);

      // Award XP
      await this.awardXP(userId, achievement.xp_reward, `achievement_${achievementId}`);

      console.log(`[UserCompetition] üèÜ User ${userId} unlocked achievement: ${achievement.name}`);

    } catch (error) {
      console.error('[UserCompetition] Error unlocking achievement:', error);
    }
  }

  /**
   * Get user profile
   */
  async getUserProfile(userId: string): Promise<UserProfile | null> {
    try {
      const { data, error } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('id', userId)
        .single();

      if (error || !data) return null;

      return this.formatUserProfile(data);

    } catch (error) {
      console.error('[UserCompetition] Error fetching user profile:', error);
      return null;
    }
  }

  /**
   * Get leaderboard (agents + users combined)
   */
  async getLeaderboard(period: 'all-time' | 'weekly' | 'monthly' = 'all-time', limit: number = 100): Promise<LeaderboardEntry[]> {
    try {
      const entries: LeaderboardEntry[] = [];

      // Get user rankings
      const { data: users, error: userError } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('is_banned', false)
        .order('total_pnl_percent', { ascending: false })
        .limit(limit);

      if (!userError && users) {
        users.forEach((user, index) => {
          entries.push({
            rank: index + 1,
            user_id: user.id,
            username: user.username,
            is_agent: false,
            total_pnl_percent: user.total_pnl_percent || 0,
            total_trades: user.total_trades || 0,
            win_rate: user.win_rate || 0,
            level: user.level || 1,
            xp: user.xp || 0
          });
        });
      }

      // Get agent rankings (from mock_trading_accounts for agent user IDs)
      const agentUserIds = ['agent-nexus-01', 'agent-quantum-x', 'agent-zeonix'];

      for (const agentId of agentUserIds) {
        const account = await mockTradingService.getOrCreateAccount(agentId);
        const positions = await mockTradingService.getOpenPositions(agentId);
        const history = await mockTradingService.getTradeHistory(agentId, 100);

        const wins = history.filter(t => t.profit_loss > 0).length;
        const winRate = history.length > 0 ? (wins / history.length) * 100 : 0;
        const totalPnLPercent = ((account.balance - account.initial_balance) / account.initial_balance) * 100;

        const agentName = agentId === 'agent-nexus-01' ? 'NEXUS-01' :
                          agentId === 'agent-quantum-x' ? 'QUANTUM-X' : 'ZEONIX';

        entries.push({
          rank: 0, // Will be sorted
          user_id: agentId,
          username: agentName,
          is_agent: true,
          agent_name: agentName,
          total_pnl_percent: totalPnLPercent,
          total_trades: account.total_trades,
          win_rate: winRate,
          level: 99, // Agents are max level
          xp: 9999
        });
      }

      // Sort by total_pnl_percent and assign ranks
      entries.sort((a, b) => b.total_pnl_percent - a.total_pnl_percent);
      entries.forEach((entry, index) => {
        entry.rank = index + 1;
      });

      return entries;

    } catch (error) {
      console.error('[UserCompetition] Error fetching leaderboard:', error);
      return [];
    }
  }

  /**
   * Get today's trade count (rate limiting)
   */
  private async getTodayTradeCount(userId: string): Promise<number> {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const { data, error } = await supabase
        .from('mock_trading_positions')
        .select('id', { count: 'exact', head: true })
        .eq('user_id', userId)
        .gte('opened_at', today.toISOString());

      return data?.length || 0;

    } catch (error) {
      console.error('[UserCompetition] Error checking trade count:', error);
      return 0;
    }
  }

  /**
   * Format user profile from database
   */
  private formatUserProfile(data: any): UserProfile {
    return {
      id: data.id,
      email: data.email,
      username: data.username,
      created_at: data.created_at,
      balance: data.balance || INITIAL_BALANCE,
      initial_balance: data.initial_balance || INITIAL_BALANCE,
      total_pnl: data.total_pnl || 0,
      total_pnl_percent: data.total_pnl_percent || 0,
      total_trades: data.total_trades || 0,
      wins: data.wins || 0,
      losses: data.losses || 0,
      win_rate: data.win_rate || 0,
      xp: data.xp || 0,
      level: data.level || 1,
      achievements: data.achievements || [],
      win_streak: data.win_streak || 0,
      max_win_streak: data.max_win_streak || 0,
      last_trade_at: data.last_trade_at,
      is_banned: data.is_banned || false
    };
  }

  /**
   * Get achievements list
   */
  getAchievementsList(): UserAchievement[] {
    return ACHIEVEMENTS;
  }
}

// Export singleton instance
export const userCompetitionService = new UserCompetitionService();
